# 개발 프로세스 및 가이드라인 (Development Process & Guidelines)

## 1. 개요

이 문서는 주식 자동매매 프로그램의 개발 프로세스, 테스트 전략, 그리고 개발 가이드라인을 정의합니다.

## 2. 개발 환경

### 2.1 시스템 요구사항
- **운영체제**: macOS (개발 환경)
- **Python 버전**: Python 3.9 이상 (백엔드)
- **Node.js 버전**: Node.js 18 이상 (프론트엔드)
- **개발 도구**: Cursor IDE
- **패키지 관리**: 
  - Python: pip 또는 uv
  - Node.js: npm 또는 yarn

### 2.2 초기 환경 설정

#### Git 레포지토리 설정
```bash
# GitHub 레포지토리 클론 (처음 한 번만)
git clone https://github.com/r8qxq969n9-ship-it/trading.git
cd trading

# 또는 기존 폴더를 레포지토리로 초기화
git init
git remote add origin https://github.com/r8qxq969n9-ship-it/trading.git
```

#### 백엔드 (Python/FastAPI)
```bash
# Python 가상환경 생성
python3 -m venv venv

# 가상환경 활성화
source venv/bin/activate

# 필수 패키지 설치
cd backend
pip install -r requirements.txt
```

#### 프론트엔드 (Next.js)
```bash
# Node.js 패키지 설치
cd frontend
npm install
# 또는
yarn install
```

#### 환경 변수 설정
```bash
# backend/.env
KIS_APP_KEY=your_app_key
KIS_APP_SECRET=your_app_secret
SLACK_WEBHOOK_URL=your_slack_webhook_url
DATABASE_URL=your_database_url

# frontend/.env.local
NEXT_PUBLIC_API_URL=http://localhost:8000
```

### 2.3 프로젝트 구조

```
trading/
├── frontend/             # Next.js 프론트엔드
│   ├── app/              # Next.js App Router
│   ├── components/       # React 컴포넌트
│   ├── lib/              # 유틸리티
│   ├── public/           # 정적 파일
│   ├── package.json
│   └── .env.local        # 프론트엔드 환경 변수
├── backend/              # FastAPI 백엔드
│   ├── app/              # 애플리케이션 코드
│   ├── config/           # 설정 파일
│   ├── requirements.txt
│   └── .env              # 백엔드 환경 변수
├── docs/                 # 문서
│   └── API/              # API 문서 (CSV 파일들)
├── tests/                # 테스트 코드
└── README.md             # 프로젝트 설명
```

## 3. 개발 방법론: 점진적 개발 (Iterative Development)

### 3.1 원칙
- **한 번에 완벽한 프로그램보다 기능을 단계적으로 추가**
- **각 기능 추가 시 커서 에이전트가 직접 테스트 수행**
- **테스트 통과 후 다음 기능 개발 진행**
- **사용자는 개발 지식이 없으므로 모든 테스트는 커서 에이전트가 담당**

### 3.2 개발 사이클

```
[기능 요구사항 분석]
         │
         ▼
[코드 구현]
         │
         ▼
[커서 에이전트 자동 테스트]
         │
    ┌────┴────┐
    │         │
  [통과]   [실패]
    │         │
    ▼         ▼
[다음 기능] [버그 수정]
```

### 3.3 병렬 개발 Phase 구조

프론트엔드와 백엔드를 병렬로 개발하여 개발 속도를 향상시킵니다. 각 Phase는 명확한 인터페이스와 의존성을 정의하여 독립적인 개발이 가능합니다.

#### Phase 0: 공통 인프라 및 인터페이스 정의 (필수 선행 작업)

**목적**: 프론트엔드와 백엔드가 독립적으로 개발할 수 있도록 인터페이스 정의

**작업 내용**:
1. 프로젝트 기본 구조 생성
   - `frontend/`, `backend/` 폴더 생성
   - 기본 설정 파일 생성
   - Git 레포지토리 초기화

2. API 인터페이스 스펙 정의
   - OpenAPI/Swagger 스펙 작성
   - REST API 엔드포인트 정의
   - 데이터 모델 정의 (Pydantic models)
   - 공통 타입 정의

3. 공통 설정 및 유틸리티
   - 환경 변수 템플릿
   - 로깅 설정
   - 에러 핸들링 표준

**의존성**: 없음  
**병렬 가능**: 아니오 (모든 Phase의 기반)  
**테스트**: 프로젝트 구조 및 스펙 검증

---

#### Phase 1: 백엔드 코어 + 프론트엔드 코어 (병렬 개발)

##### Phase 1A: 백엔드 코어 (백엔드 팀)

**목적**: 한국투자증권 API 통합 및 기본 백엔드 인프라 구축

**작업 내용**:
1. 인증 모듈
   - 한국투자증권 Open API 인증 구현
   - 토큰 관리 및 자동 갱신
   - 실전/모의투자 환경 전환

2. API 클라이언트
   - REST API 클라이언트 구현
   - 현재가 조회 API
   - 호가창 조회 API
   - 계좌 정보 조회 API

3. 데이터베이스 설정
   - PostgreSQL/SQLite 설정
   - 기본 스키마 생성
   - 데이터 모델 정의

4. 기본 API 엔드포인트
   - `/api/auth` - 인증 관련
   - `/api/price` - 시세 조회
   - `/api/account` - 계좌 정보
   - OpenAPI 문서 자동 생성

**의존성**: Phase 0 완료  
**병렬 가능**: Phase 1B와 병렬  
**테스트**: 인증 테스트, API 호출 테스트, 데이터베이스 연동 테스트

---

##### Phase 1B: 프론트엔드 코어 (프론트엔드 팀)

**목적**: 기본 UI 구조 및 상태 관리 구축

**작업 내용**:
1. Next.js 프로젝트 설정
   - Next.js 14+ 프로젝트 초기화
   - Tailwind CSS 설정
   - 기본 라우팅 구조

2. UI 컴포넌트 라이브러리
   - shadcn/ui 설치 및 설정
   - 기본 컴포넌트 (Button, Input, Card 등)
   - 레이아웃 컴포넌트

3. 상태 관리 설정
   - Zustand 또는 React Query 설정
   - API 클라이언트 설정 (axios/fetch)
   - 환경 변수 설정

4. 기본 페이지 구조
   - 로그인 페이지 (UI만, 실제 인증은 Phase 2)
   - 대시보드 레이아웃
   - 네비게이션 메뉴

**의존성**: Phase 0 완료  
**병렬 가능**: Phase 1A와 병렬  
**주의**: 실제 API 호출은 Mock 데이터 사용  
**테스트**: UI 컴포넌트 테스트, 라우팅 테스트

---

#### Phase 2: 백엔드 비즈니스 로직 + 프론트엔드 기능 (병렬 개발)

##### Phase 2A: 백엔드 비즈니스 로직 (백엔드 팀)

**목적**: 자동매매 전략 및 주문 관리 구현

**작업 내용**:
1. 전략 모듈
   - 전략 인터페이스 정의
   - 이동평균선 교차 전략 구현
   - RSI 전략 구현

2. 주문 관리
   - 주문 실행 모듈
   - 주문 취소/수정 기능
   - 주문 내역 저장

3. 리스크 관리
   - 손절매/익절매 로직
   - 포지션 크기 관리
   - 일일 손실 한도 체크

4. API 엔드포인트 확장
   - `/api/strategy` - 전략 관리
   - `/api/order` - 주문 관리
   - `/api/risk` - 리스크 관리

**의존성**: Phase 1A 완료  
**병렬 가능**: Phase 2B와 병렬  
**테스트**: 전략 로직 테스트, 주문 실행 테스트, 리스크 관리 테스트

---

##### Phase 2B: 프론트엔드 기능 구현 (프론트엔드 팀)

**목적**: 실제 API 연동 및 주요 기능 UI 구현

**작업 내용**:
1. API 연동
   - Phase 1A에서 정의한 API 실제 호출
   - 인증 플로우 구현
   - 에러 핸들링

2. 대시보드 구현
   - 포트폴리오 현황 표시
   - 보유 종목 목록
   - 수익/손실 표시

3. 자동매매 설정 UI
   - 전략 선택 폼
   - 파라미터 설정 UI
   - 리스크 관리 설정 UI

4. 주문 관리 UI
   - 주문 내역 테이블
   - 주문 실행 폼
   - 주문 취소/수정 UI

**의존성**: Phase 1B 완료, Phase 1A API 스펙 참조  
**병렬 가능**: Phase 2A와 병렬 (Mock 데이터로 먼저 개발 후 연동)  
**테스트**: API 연동 테스트, UI 기능 테스트, 통합 테스트

---

#### Phase 3: 실시간 기능 및 통합 (순차/병렬 혼합)

##### Phase 3A: 백엔드 실시간 기능 (백엔드 팀)

**목적**: WebSocket 및 실시간 알림 구현

**작업 내용**:
1. WebSocket 서버
   - FastAPI WebSocket 구현
   - 한국투자증권 WebSocket 클라이언트
   - 실시간 시세 수신 및 브로드캐스트

2. 알림 시스템
   - Slack Webhook 연동
   - 알림 전송 모듈
   - 이벤트 기반 알림

3. 실시간 API
   - WebSocket 엔드포인트
   - 실시간 시세 스트리밍
   - 체결 알림

**의존성**: Phase 2A 완료  
**병렬 가능**: Phase 3B와 부분 병렬  
**테스트**: WebSocket 연결 테스트, 실시간 데이터 전송 테스트, Slack 알림 테스트

---

##### Phase 3B: 프론트엔드 실시간 UI (프론트엔드 팀)

**목적**: 실시간 데이터 표시 및 차트 구현

**작업 내용**:
1. WebSocket 클라이언트
   - WebSocket 연결 관리
   - 실시간 데이터 수신
   - 재연결 로직

2. 실시간 차트
   - TradingView Lightweight Charts 또는 Recharts
   - 실시간 가격 업데이트
   - 캔들스틱 차트

3. 실시간 알림 UI
   - 알림 토스트 컴포넌트
   - 알림 히스토리
   - 알림 설정 UI

**의존성**: Phase 2B 완료, Phase 3A WebSocket 스펙 참조  
**병렬 가능**: Phase 3A와 부분 병렬 (WebSocket 스펙 정의 후)  
**테스트**: WebSocket 클라이언트 테스트, 차트 렌더링 테스트, 실시간 업데이트 테스트

---

#### Phase 4: 고급 기능 (병렬 개발)

##### Phase 4A: 백테스팅 엔진 (백엔드 팀)

**목적**: 전략 백테스팅 기능 구현

**작업 내용**:
1. 백테스팅 엔진
   - 과거 데이터 로드
   - 전략 시뮬레이션
   - 성과 지표 계산

2. 백테스팅 API
   - `/api/backtest` - 백테스팅 실행
   - `/api/backtest/results` - 결과 조회

**의존성**: Phase 2A 완료  
**병렬 가능**: Phase 4B와 병렬  
**테스트**: 백테스팅 로직 테스트, 성과 지표 계산 테스트

---

##### Phase 4B: 백테스팅 UI 및 시각화 (프론트엔드 팀)

**목적**: 백테스팅 결과 시각화 및 성과 분석

**작업 내용**:
1. 백테스팅 UI
   - 백테스팅 설정 폼
   - 결과 표시 페이지
   - 성과 지표 차트

2. 고급 시각화
   - 성과 분석 그래프
   - 수익률 추이 차트
   - 리스크 지표 시각화

**의존성**: Phase 2B 완료, Phase 4A API 스펙 참조  
**병렬 가능**: Phase 4A와 병렬 (API 스펙 정의 후)  
**테스트**: UI 테스트, 차트 렌더링 테스트, 데이터 시각화 테스트

---

#### Phase 5: ML/AI 전략 (향후 확장)

**목적**: 머신러닝 기반 전략 구현

**작업 내용**:
- ML 모델 개발
- 전략 통합
- 성능 최적화

**의존성**: Phase 2 완료  
**병렬 가능**: 독립적으로 개발 가능  
**테스트**: ML 모델 테스트, 전략 성능 테스트

---

### 3.4 병렬 개발 전략

#### 병렬 개발 가능 Phase 요약

| Phase | 백엔드 | 프론트엔드 | 병렬 가능 |
|-------|--------|-----------|----------|
| Phase 0 | 공통 인프라 | 공통 인프라 | ❌ (순차) |
| Phase 1 | 백엔드 코어 | 프론트엔드 코어 | ✅ |
| Phase 2 | 비즈니스 로직 | 기능 UI | ✅ |
| Phase 3 | 실시간 기능 | 실시간 UI | ⚠️ (부분 병렬) |
| Phase 4 | 백테스팅 엔진 | 백테스팅 UI | ✅ |

#### 병렬 개발 시 주의사항

1. **API 스펙 우선 정의**
   - Phase 0에서 OpenAPI 스펙 작성
   - 프론트엔드는 Mock 서버로 개발 가능
   - 스펙 변경 시 즉시 공유

2. **인터페이스 우선 설계**
   - 데이터 모델 먼저 정의
   - API 엔드포인트 스펙 공유
   - 타입 정의 공유

3. **통합 테스트**
   - 각 Phase 완료 후 통합 테스트
   - API 호환성 검증
   - 엔드투엔드 테스트

4. **커뮤니케이션**
   - API 스펙 변경 시 즉시 공유
   - 주간 동기화 미팅 권장
   - 문서 업데이트 필수

**각 Phase는 독립적으로 완성되어야 하며, 다음 Phase로 진행하기 전에 반드시 테스트를 통과해야 합니다.**

## 4. 테스트 전략

### 4.1 테스트 원칙
- **모든 테스트는 커서 에이전트가 자동으로 수행**
- **사용자는 개발 지식이 없으므로 테스트 코드 작성 및 실행은 커서 에이전트가 담당**
- **각 기능 구현 후 즉시 테스트 수행**
- **테스트 실패 시 버그 수정 후 재테스트**

### 4.2 테스트 유형

#### 4.2.1 단위 테스트 (Unit Tests)
- **목적**: 개별 함수/메서드의 정확성 검증
- **범위**: 
  - 인증 모듈
  - API 클라이언트
  - 전략 로직
  - 리스크 관리 로직
  - 데이터 처리 함수
- **도구**: pytest
- **실행**: 커서 에이전트가 자동 실행

#### 4.2.2 통합 테스트 (Integration Tests)
- **목적**: 모듈 간 상호작용 검증
- **범위**:
  - API 통신 통합
  - 데이터베이스 연동
  - 전략 엔진과 주문 관리 연동
- **도구**: pytest
- **실행**: 커서 에이전트가 자동 실행

#### 4.2.3 기능 테스트 (Functional Tests)
- **목적**: 사용자 시나리오 기반 전체 기능 검증
- **범위**:
  - 자동매매 시작 시나리오
  - 실시간 모니터링 시나리오
  - 백테스팅 시나리오
  - 리스크 관리 시나리오
- **도구**: pytest + 모의(Mock) API
- **실행**: 커서 에이전트가 자동 실행

#### 4.2.4 GUI 테스트 (GUI Tests)
- **목적**: 사용자 인터페이스 동작 검증
- **범위**:
  - 화면 전환
  - 버튼 클릭 동작
  - 데이터 표시
  - 차트 렌더링
- **도구**: pytest-qt 또는 직접 테스트
- **실행**: 커서 에이전트가 자동 실행

### 4.3 테스트 실행 규칙

1. **코드 커밋 전**: 모든 단위 테스트 및 통합 테스트 통과 필수
2. **기능 완성 시**: 해당 기능의 기능 테스트 통과 필수
3. **GUI 변경 시**: GUI 테스트 통과 필수
4. **테스트 실패 시**: 즉시 버그 수정 후 재테스트

### 4.4 테스트 커버리지 목표
- **단위 테스트**: 최소 80% 이상
- **통합 테스트**: 핵심 모듈 100%
- **기능 테스트**: 모든 주요 시나리오 100%

## 5. 코드 품질 관리

### 5.1 코딩 스타일
- **Python 스타일 가이드**: PEP 8 준수
- **도구**: black (포맷팅), flake8 (린팅)
- **자동 검사**: 커서 에이전트가 코드 작성 시 자동 적용

### 5.2 코드 리뷰
- **리뷰어**: 커서 에이전트
- **리뷰 항목**:
  - 코드 스타일 준수
  - 로직 정확성
  - 에러 핸들링
  - 성능 최적화
  - 보안 취약점

### 5.3 문서화
- **함수/클래스**: docstring 필수
- **주요 모듈**: README 또는 주석으로 설명
- **API 사용법**: 예제 코드 포함

## 6. 버전 관리

### 6.1 Git 워크플로우
- **레포지토리**: [https://github.com/r8qxq969n9-ship-it/trading.git](https://github.com/r8qxq969n9-ship-it/trading.git)
- **브랜치 전략**: 
  - `main`: 안정적인 릴리스 버전
  - `develop`: 개발 중인 버전
  - `feature/*`: 기능 개발 브랜치
- **커밋 메시지**: 명확하고 구체적으로 작성
- **커밋 주기**: 기능 단위로 커밋
- **로컬 개발**: 모든 개발은 로컬에서 수행하며, 완료된 기능은 GitHub에 푸시
- **자동 배포**: GitHub에 푸시하면 Vercel/Railway가 자동으로 배포

### 6.2 버전 번호
- **형식**: Semantic Versioning (MAJOR.MINOR.PATCH)
- **예시**: v1.0.0, v1.1.0, v1.1.1

### 6.3 Git 커밋 전략

#### 커밋 시점
1. **문서 작성/수정 완료 시**: PRD, 개발 가이드 등 문서 업데이트 후
2. **각 Phase 완료 시**: Phase별 작업 완료 및 테스트 통과 후
3. **기능 단위 개발 완료 시**: 독립적인 기능 구현 완료 후
4. **테스트 통과 후**: 모든 테스트 통과 확인 후
5. **작업 세션 종료 전**: 하루 작업 마무리 시

#### 커밋 메시지 규칙
- **형식**: `[타입] 간단한 설명`
- **타입**:
  - `docs`: 문서 수정
  - `feat`: 새로운 기능 추가
  - `fix`: 버그 수정
  - `refactor`: 코드 리팩토링
  - `test`: 테스트 추가/수정
  - `chore`: 빌드/설정 변경
- **예시**:
  - `[docs] 병렬 개발 Phase 구조 추가`
  - `[feat] 인증 모듈 구현`
  - `[fix] API 호출 에러 핸들링 수정`

#### 커밋 전 체크리스트
- [ ] 코드/문서 변경사항 확인
- [ ] 테스트 통과 확인 (해당되는 경우)
- [ ] 린팅 통과 확인 (해당되는 경우)
- [ ] 커밋 메시지 작성
- [ ] 변경사항 검토

#### 자동 커밋 및 푸시
- **작업 완료 시**: 각 작업의 마지막 단계에서 자동으로 커밋 및 푸시 수행
- **일일 마무리**: 하루 작업 종료 시 변경사항 커밋 및 푸시
- **Phase 완료**: Phase 완료 시 해당 Phase의 모든 변경사항 커밋 및 푸시

#### 커밋 예시
```bash
# 문서 업데이트
git add prd.md DEVELOPMENT.md
git commit -m "[docs] 병렬 개발 Phase 구조 추가"
git push origin main

# 기능 개발 완료
git add backend/app/auth/
git commit -m "[feat] 한국투자증권 Open API 인증 모듈 구현"
git push origin develop
```

## 7. 배포 프로세스

### 7.1 웹 애플리케이션 배포

#### 프론트엔드 배포 (Vercel)
1. GitHub 레포지토리에 코드 푸시
2. Vercel 계정 생성 및 GitHub 연동
3. 프로젝트 import (자동 감지)
4. 환경 변수 설정 (Vercel 대시보드)
5. 자동 배포 완료
6. 배포 URL 확인 (예: `https://trading-app.vercel.app`)

#### 백엔드 배포 (Railway 또는 Render)
1. Railway/Render 계정 생성
2. GitHub 레포지토리 연결
3. 프로젝트 생성 및 설정
4. 환경 변수 설정 (API 키, 데이터베이스 URL 등)
5. 자동 배포 완료
6. 백엔드 URL 확인

#### 데이터베이스 설정
- **옵션 1**: Supabase (PostgreSQL, 무료 플랜)
- **옵션 2**: Railway PostgreSQL (무료 플랜)
- **옵션 3**: SQLite (초기 개발용, 프로덕션 비권장)

#### 접속 방법
- 사용자는 Vercel에서 제공하는 URL로 접속
- 모바일 브라우저에서도 동일 URL로 접속 가능
- 북마크 추가로 앱처럼 사용 가능

### 7.2 배포 체크리스트
- [ ] 모든 테스트 통과
- [ ] 코드 린팅 통과
- [ ] 환경 변수 설정 완료 (Vercel, Railway/Render)
- [ ] 데이터베이스 연결 확인
- [ ] Slack 웹훅 URL 설정
- [ ] API 엔드포인트 테스트
- [ ] 프론트엔드-백엔드 통신 확인
- [ ] 문서 업데이트
- [ ] 사용자 가이드 작성

## 8. 디버깅 및 문제 해결

### 8.1 로깅 전략
- **레벨**: DEBUG, INFO, WARNING, ERROR, CRITICAL
- **파일**: `logs/trading_YYYY-MM-DD.log`
- **포맷**: 타임스탬프, 레벨, 모듈, 메시지

### 8.2 에러 핸들링
- **원칙**: 모든 예외 상황 처리
- **로깅**: 모든 에러는 로그에 기록
- **사용자 알림**: 중요한 에러는 GUI로 알림

### 8.3 문제 해결 프로세스
1. 에러 로그 확인
2. 문제 재현
3. 원인 분석
4. 수정 및 테스트
5. 재배포

## 9. 지속적 개선

### 9.1 성능 모니터링
- API 응답 시간 측정
- 메모리 사용량 모니터링
- 데이터베이스 쿼리 최적화

### 9.2 기능 추가 프로세스
1. 기능 요구사항 정의
2. 설계 및 구현
3. 테스트 수행
4. 문서 업데이트
5. 배포

### 9.3 사용자 피드백 반영
- 사용자 요청사항 수집
- 우선순위 결정
- 개발 계획 수립
- 구현 및 테스트

## 10. 커서 에이전트 활용 가이드

### 10.1 개발 작업 흐름
1. **요구사항 제시**: 사용자가 원하는 기능 설명
2. **코드 구현**: 커서 에이전트가 코드 작성
3. **자동 테스트**: 커서 에이전트가 테스트 실행
4. **결과 확인**: 테스트 통과 여부 확인
5. **다음 단계**: 통과 시 다음 기능 개발, 실패 시 버그 수정

### 10.2 커서 에이전트에게 요청할 수 있는 작업
- 코드 구현
- 테스트 작성 및 실행
- 버그 수정
- 코드 리팩토링
- 문서 작성
- 성능 최적화

### 10.3 효과적인 커밋 활용
- 명확한 요청: 구체적인 기능 설명
- 단계별 요청: 한 번에 너무 많은 기능 요청 지양
- 피드백 제공: 결과에 대한 피드백 제공

## 11. 참고 자료

### 11.1 관련 문서
- [PRD.md](prd.md): 제품 요구사항 문서
- [README.md](README.md): 프로젝트 개요

### 11.2 외부 리소스
- [한국투자증권 Open API 문서](https://apiportal.koreainvestment.com)
- [프로젝트 API 문서](docs/API/) - CSV 파일들 (KIS GitHub 레포지토리가 더 최신이면 우선 활용)
- [Python 공식 문서](https://docs.python.org/)
- [FastAPI 문서](https://fastapi.tiangolo.com/)
- [Next.js 문서](https://nextjs.org/docs)
- [Vercel 배포 가이드](https://vercel.com/docs)
- [Railway 배포 가이드](https://docs.railway.app/)
- [Slack Webhook 가이드](https://api.slack.com/messaging/webhooks)

## 12. Slack 알림 시스템 구현

### 12.1 Slack 웹훅 설정
1. Slack 워크스페이스 접속
2. Apps 메뉴에서 "Incoming Webhooks" 검색 및 추가
3. 알림을 받을 채널 선택
4. Webhook URL 복사
5. 백엔드 환경 변수에 `SLACK_WEBHOOK_URL` 설정

### 12.2 알림 구현
```python
# backend/app/notifications/slack.py
import requests
import json

def send_slack_notification(webhook_url: str, message: dict):
    """Slack 웹훅을 통해 알림 전송"""
    response = requests.post(webhook_url, json=message)
    return response.status_code == 200
```

### 12.3 알림 유형별 구현
- **긴급 알림**: 주문 체결, 손실 한도 도달, 시스템 오류
- **일반 알림**: 리스크 경고, 포지션 변경
- **정보 알림**: 일일 수익률 요약, 전략 실행 결과

### 12.4 알림 포맷
- 구조화된 메시지 (제목, 본문, 링크)
- 색상 코딩 (빨강: 긴급, 노랑: 경고, 초록: 정보)
- 이모지 활용

## 13. 변경 이력

- 2026-01-18: 초안 작성
- 2026-01-18: 웹 애플리케이션으로 변경, Vercel/Railway 배포 추가, Slack 알림 시스템 추가
- 2026-01-18: 병렬 개발 Phase 구조로 재구성 (프론트엔드/백엔드 병렬 개발 전략 추가)